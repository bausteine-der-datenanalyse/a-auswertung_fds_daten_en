{
  "hash": "7a2ac104041ddafc9b6b1f79f4e03bd7",
  "result": {
    "engine": "jupyter",
    "markdown": "# Fdsreader\n\nIn order to analyse simulation data computed by FDS with Python, the group of \nProf. Lukas Arnold has developed the Python module fdsreader. Its aim is to \nread most data output formats generated by FDS and map them to Python data \nstructures.\n\nThe freely available and open source. The source code is hosted at GitHub: \n[FireDynamics/fdsreader](https://github.com/FireDynamics/fdsreader) and there \nis also an [API documentation](https://firedynamics.github.io/fdsreader/index.html).\n\n## Installing and importing the package\n\nThe fdsreader module can be installed via pip (see also the GitHub repository):\n\n```default\npip install fdsreader\n```\n\nTo learn the basic usage of the fdsreader module we will look at a simple \nFDS scenario. Lets first import the module:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport fdsreader\n```\n:::\n\n\nSince we will also plot the data we will import `matplotlib`too.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n## Choosing the correct folder\n\nNext, the reader needs to be pointed to the directory, which contains the \nsimulation data, especailly the smokeview file.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# define the path to the data\npath_to_data = '../skript/01-data/first_example'\n\nsim = fdsreader.Simulation(path_to_data)\n```\n:::\n\n\nThe `Simulation` object `sim` contains now all the information and data about \nthe simulaiton output:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nsim\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nSimulation(chid=StecklerExample,\n           meshes=1,\n           obstructions=7,\n           slices=5,\n           data_3d=5,\n           smoke_3d=3,\n           devices=4)\n```\n:::\n:::\n\n\nThe variable `sim` contains information about the mesh (`MESH`), four slices (`SLCF`) \nand four point measurements (`DEVC`). The additional device – there were just \nthree defined in the FDS input file – is the time column.\n\n## Device Data\n\n::: {.callout-tip}\n## Devices in FDS\nDevices act like virtual sensors, allowing one to record data such as \ntemperature, heat flux, gas concentration, velocity, and more, at specific \nlocations within the simulation domain. This data can be crucial for \nunderstanding the behavior of fire and smoke under different conditions.\n\nA device can get a label (`ID`), which makes it much easier to identify in the \ncomma separated value (CSV) file created during the simulation. It needs a \nlocation and a quantity.\n\nLocations can be provided in different ways, we focus her on a single point \nusing `XYZ`. However, lines, planes and volumes are possible as well.\n\nThe `QUANTITY` parameter expects a string to define what values are to be \nrecorded. As an example, let’s take the gas temperature, using `TEMPERATURE`.\n:::\n\nThe simplest data set is the output of the DEVC directives. The available data \nand meta information can be directly printed:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# short reference for convinience, i.e. `devc` contains all devices\ndevc = sim.devices\nprint(devc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[Device(id='Time', xyz=(0.0, 0.0, 0.0), quantity=Quantity('TIME')),\nDevice(id='Temp_Door_Low', xyz=(1.45, 0.05, 0.1), quantity=Quantity('TEMPERATURE')),\nDevice(id='Temp_Door_Mid', xyz=(1.45, 0.05, 1.0), quantity=Quantity('TEMPERATURE')),\nDevice(id='Temp_Door_High', xyz=(1.45, 0.05, 1.65), quantity=Quantity('TEMPERATURE'))]\n```\n:::\n:::\n\n\nThe Device class contains all relevant information, see \n[device documentation](https://firedynamics.github.io/fdsreader/devc.html).\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nfor i in devc:\n    print(f\"ID: {i.id},\\t quantity: {i.quantity_name}, \\t position: {i.position}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nID: Time,\t quantity: TIME, \t position: (0.0, 0.0, 0.0)\nID: Temp_Door_Low,\t quantity: TEMPERATURE, \t position: (1.45, 0.05, 0.1)\nID: Temp_Door_Mid,\t quantity: TEMPERATURE, \t position: (1.45, 0.05, 1.0)\nID: Temp_Door_High,\t quantity: TEMPERATURE, \t position: (1.45, 0.05, 1.65)\n```\n:::\n:::\n\n\nIndividual devices, including the time column, are accessable as dictironary \nentries using their ID as key. The data of each individual device (Device.data) \nis stored as a numpy array:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ntype(devc['Temp_Door_Mid'].data)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\nnumpy.ndarray\n```\n:::\n:::\n\n\nThe length matches the expected value, i.e. 1801, as the simulation time was\nand the divices were writen out every second, including the initial time step, \nhere at `t = 0s`.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nlen(devc['Time'].data)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n1801\n```\n:::\n:::\n\n\nA raw look at the data (`Device.data`):\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ndevc['Temp_Door_Mid'].data\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([ 20.      ,  20.002083,  20.034418, ..., 105.32822 , 114.82179 ,\n       115.01705 ], dtype=float32)\n```\n:::\n:::\n\n\nThe device data can be also visualised with matplotlib:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# create the plot\nplt.plot(devc['Time'].data, devc['Temp_Door_High'].data)\n\n# label the axes\nplt.xlabel(\"time / s\")\ndevc_id = devc['Temp_Door_High'].id\ndevc_q = devc['Temp_Door_High'].quantity_name\ndevc_u = devc['Temp_Door_High'].unit\nplt.ylabel(f\"{devc_q} ({devc_id}) / {devc_u}\")\n\n# add a grid\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-11-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nIn the same manner a set of devices can be plotted at once. Like all devices with names starting with Temp_:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\n# loop over all devices\nfor i in devc:\n    \n    # consider only devices with an ID that starts with 'Temp_'\n    if not i.id.startswith('Temp_'): \n        continue\n    \n    plt.plot(devc[\"Time\"].data, i.data, label=i.id)\n    \nplt.legend()\nplt.xlabel(\"time / s\")\nplt.ylabel('temperature / $^\\circ$C')\nplt.grid()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<>:12: SyntaxWarning: invalid escape sequence '\\c'\n<>:12: SyntaxWarning: invalid escape sequence '\\c'\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_85247/1295739546.py:12: SyntaxWarning: invalid escape sequence '\\c'\n  plt.ylabel('temperature / $^\\circ$C')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-12-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n## HRR Data\n\n::: {.callout-tip}\n## Heat Release Rate (HRR)\nThe crucial parameter in fire modeling, representing the rate at which energy \nis released by a fire, typically measured in kilowatts (kW) or megawatts (MW).\n:::\n\nIn the same fashion as the `DEVC` data, the data written to the `HRR` file can \nbe directly accessed. It is not stored in the `devices` but in the `hrr` element \nof the `Simulation` object.\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nplt.plot(sim.hrr['Time'], sim.hrr['HRR'], label='heat release from fire')\n\nplt.plot(sim.hrr['Time'], sim.hrr['Q_RADI'], label='radiative')\nplt.plot(sim.hrr['Time'], sim.hrr['Q_COND'], label='conductive')\nplt.plot(sim.hrr['Time'], sim.hrr['Q_CONV'], label='convective')\n\nplt.plot(sim.hrr['Time'], \n         sim.hrr['HRR'] + sim.hrr['Q_RADI'] + sim.hrr['Q_COND'] + sim.hrr['Q_CONV'], \n         color='grey', label='sum', zorder=0)\n\nplt.xlabel('time / s')\nplt.ylabel('heat flow rate / kW')\nplt.legend()\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-13-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Slice Data\n\n::: {.callout-tip}\n## Slice data\nSclices are a type of output that allows you to visualize the distribution of \nspecific quantities (e.g., temperature, velocity, smoke concentration) within a \nplane of the simulation domain. These slices are essentially cross-sectional \nviews of the data, providing insight into how these quantities vary within a \nspecific area of the simulated environment.\n:::\n\nData generated by `SLCF` directives span over two or three spatial dimensions \nplus the time dimension. Besides that, they can be distributed across multiple \nmeshes.\n\nThe data of a slice is stored for each mesh individually. In this simple \nexample, there is only a single mesh, yet for formal consistency it still \nneeds to be referred.\n\nThe data structure is as follows:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nsim.slices[sliceid][meshid].data[timestep, direction1, direction2]\n```\n:::\n\n\nwhere `sliceid` is just the index of the slice, `meshid` is the index of the \nmesh, here in this example 0, and the reference to the data is given by the \ntime step id and then the two spatial indices (for two dimensional slices).\n\nIn general there are multiple slice objects available:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# print available slice data\nfor slice in sim.slices:\n    print(f\"Slice Type [2D/3D]: {slice.type}\\n  Quantity: {slice.quantity.name}\\n\", \n          f\" Physical Extent: {slice.extent}\\n  Orientation [1/2/3]: {slice.orientation}\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSlice Type [2D/3D]: 2D\n  Quantity: TEMPERATURE\n  Physical Extent: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])\n  Orientation [1/2/3]: 1\n\nSlice Type [2D/3D]: 2D\n  Quantity: TEMPERATURE\n  Physical Extent: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])\n  Orientation [1/2/3]: 2\n\nSlice Type [2D/3D]: 2D\n  Quantity: W-VELOCITY\n  Physical Extent: Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20])\n  Orientation [1/2/3]: 1\n\nSlice Type [2D/3D]: 2D\n  Quantity: U-VELOCITY\n  Physical Extent: Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20])\n  Orientation [1/2/3]: 2\n\nSlice Type [2D/3D]: 2D\n  Quantity: W-VELOCITY\n  Physical Extent: Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80])\n  Orientation [1/2/3]: 3\n\n```\n:::\n:::\n\n\nThere are multiple ways to find the right slice in the set of all slices. \nOne way is to filter for a quantity using the `filter_by_quantity` function or \nchoose a slice by its ID.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# get the W-VELOCITY slice(s)\nw_slice = sim.slices.filter_by_quantity(\"W-VELOCITY\")\nprint(w_slice)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSliceCollection([Slice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([0.00, 0.00] x [-1.40, 1.40] x [0.00, 2.20]), extent_dirs=('y', 'z'), orientation=1),\nSlice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)])\n```\n:::\n:::\n\n\nAnother way is to select a slice based on its distance to a given point.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n# select slice, by its distance to a given point\nslc = w_slice.get_nearest(x=1, z=2)\nprint(slc)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSlice([2D] quantity=Quantity('W-VELOCITY'), cell_centered=False, extent=Extent([-1.40, 2.60] x [-1.40, 1.40] x [1.80, 1.80]), extent_dirs=('x', 'y'), orientation=3)\n```\n:::\n:::\n\n\nTo access the actual slice data, the actual mesh and a point in time needs to \nbe specified. In this example, there is only one mesh, thus the index is 0. The \nfunction `get_nearest_timestemp` helps to find the right time index.\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# choose and output the time step, next to t=75 s\nit = slc.get_nearest_timestep(25)\nprint(f\"Time step: {it}\")\nprint(f\"Simulation time: {slc.times[it]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTime step: 25\nSimulation time: 25.02111\n```\n:::\n:::\n\n\nThe following example illustrates the visualisation of the data and steps needed \nto adjust the representation. The needed adjustments are due to the data \norientation expected by the `imshow` function.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n# choose the temperature slice in y-direction\nslc = sim.slices.filter_by_quantity('TEMPERATURE').get_nearest(x=3, y=0)\nprint(slc)\n# only one mesh\nslc_data = slc[0].data\nprint(slc_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSlice([2D] quantity=Quantity('TEMPERATURE'), cell_centered=False, extent=Extent([-1.40, 2.60] x [0.00, 0.00] x [0.00, 2.20]), extent_dirs=('x', 'z'), orientation=2)\n[[[ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  ...\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]\n  [ 20.        20.        20.       ...  20.        20.        20.      ]]\n\n [[ 20.030926  20.031328  20.032204 ...  20.001385  20.001268  20.00117 ]\n  [ 20.030703  20.031597  20.033634 ...  20.001493  20.001345  20.001238]\n  [ 20.031723  20.033785  20.038801 ...  20.001757  20.001535  20.001389]\n  ...\n  [ 20.006077  20.004908  20.002953 ...  20.001383  20.001154  20.00104 ]\n  [ 20.005085  20.004053  20.00236  ...  20.00129   20.001116  20.001026]\n  [ 20.004608  20.003656  20.0021   ...  20.00125   20.001104  20.001026]]\n\n [[ 20.12404   20.126698  20.133305 ...  20.026028  20.02525   20.025595]\n  [ 20.116137  20.11882   20.12633  ...  20.02626   20.025606  20.02608 ]\n  [ 20.114033  20.117645  20.128752 ...  20.02802   20.027351  20.027908]\n  ...\n  [ 20.018784  20.016739  20.013128 ...  20.00563   20.004776  20.004353]\n  [ 20.015898  20.014067  20.010876 ...  20.005054  20.004427  20.004118]\n  [ 20.01441   20.012737  20.00983  ...  20.004791  20.004278  20.00403 ]]\n\n ...\n\n [[ 44.00391   43.917053  43.920734 ... 143.89009  142.69537  142.16621 ]\n  [ 44.004223  43.863914  43.708996 ... 143.29715  142.09953  141.6622  ]\n  [ 43.81018   43.64982   43.4085   ... 142.64955  141.90448  141.75969 ]\n  ...\n  [ 20.284891  20.19156   20.076902 ...  90.631195  78.81051   72.00585 ]\n  [ 20.218634  20.140545  20.047134 ...  56.04536   43.176456  39.645744]\n  [ 20.151264  20.09307   20.028439 ...  34.67456   27.534237  27.970665]]\n\n [[ 45.228874  45.115242  44.938766 ... 150.18481  150.12732  149.83371 ]\n  [ 44.492287  44.350613  44.180614 ... 149.79759  150.0778   149.77635 ]\n  [ 43.646873  43.590538  43.562504 ... 147.7298   148.82109  149.29768 ]\n  ...\n  [ 20.281096  20.186028  20.071451 ... 106.69953   93.09295   83.79199 ]\n  [ 20.205025  20.13359   20.046276 ...  80.62758   71.11945   62.30358 ]\n  [ 20.16152   20.102564  20.033293 ...  65.56552   56.724525  46.839134]]\n\n [[ 42.762764  42.892406  42.67096  ... 146.0912   145.20709  144.58104 ]\n  [ 43.14627   43.263447  43.141045 ... 145.02187  144.6713   143.69063 ]\n  [ 43.753468  43.769325  43.798447 ... 141.0417   142.32797  141.77148 ]\n  ...\n  [ 20.268656  20.194078  20.08938  ...  72.89162   70.64532   65.348694]\n  [ 20.206676  20.136755  20.052374 ...  59.554634  49.809177  42.573883]\n  [ 20.180956  20.111738  20.035168 ...  48.16472   36.145966  31.134487]]]\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\n# Initial visualasation of the data at time t=50 s\nit = slc.get_nearest_timestep(50)\nplt.imshow(slc_data[it])\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-20-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\n# Access the transpose data using ndarray.T and set the origin of the output\nplt.imshow(slc_data[it].T, origin='lower')\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-21-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\n# Initial visualasation of the data at time t=50 s\n# Finally, also the extend is specified to move from index to physical space\n# Additionally, the maximal value is set using the vmax argument\nplt.imshow(slc_data[it].T, \n           origin='lower',\n           vmax=200,\n           extent=slc.extent.as_list())\nplt.colorbar(label='temperature / C', orientation='horizontal')\nplt.xlabel('x coordinate / m')\nplt.ylabel('z coordinate / m')\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nText(0, 0.5, 'z coordinate / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-22-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\n# Example for a multi plot\nlist_t = [0, 50, 100, 200, 300, 400]\nfig, axs = plt.subplots(2,3, sharex=True, sharey=True)\nfor i in range(len(list_t)):\n    it = slc.get_nearest_timestep(list_t[i])\n    axs.flat[i].imshow(slc_data[it].T,\n                       vmin=20,\n                       vmax=400,\n                       origin='lower', \n                       extent=slc.extent.as_list())\n    axs.flat[i].set_title(f\"t={slc.times[it]:.1f}\")\n```\n\n::: {.cell-output .cell-output-display}\n![](fdsreader_files/figure-pdf/cell-23-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "fdsreader_files/figure-pdf"
    ],
    "filters": []
  }
}