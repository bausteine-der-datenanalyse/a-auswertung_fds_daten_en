{
  "hash": "6c0770fe3b4cfb48c7b128073ff8321b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Available safe egress time\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport fdsreader\nimport matplotlib.pyplot as plt\nimport numpy as np\n```\n:::\n\n\nThis example demonstrates an analysis of slice data, here to determine the map \nof available safe egress time (ASET) and the temporal evolution of the smoke \nlayer height. The used scenario is a multi-room appartment.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\npath_to_data = '../skript/01-data/apartment_01'\n\nsim = fdsreader.Simulation(path_to_data)\nprint(sim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimulation(chid=Appartment,\n           meshes=8,\n           obstructions=23,\n           slices=20,\n           data_3d=5,\n           smoke_3d=3)\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# get the soot density slice, normal to z at 1.5m height\nslc = sim.slices.get_by_id('SootDensityZ_1.5m')\n\n# as the simulation is based on multiple meshes, a global \n# data structure is created, walls are represented as\n# non-valid data points, i.e. nan\nslc_data = slc.to_global(masked=True, fill=np.nan)\n```\n:::\n\n\nFirst, a visualisation of the data at a selected point is done with the `imshow` function.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n# find the time index\nit = slc.get_nearest_timestep(50)\n\n# visualise the data\nplt.imshow(slc_data[it,:,:].T, origin='lower', extent=slc.extent.as_list())\n\n# add labels\nplt.title(f'Soot Density at t={slc.times[it]:.2f}s')\nplt.xlabel('position / m')\nplt.ylabel('position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}' )\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-5-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nNow, the local ASET values are computed:\n\n1. Iterate over all spatial elements of the slice\n2. Determine all points in time which exceed the tenability threshold\n3. f this happens at any time, set the first time to be the local ASET value\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\n# set arbitrary values as tenability threshold\nsoot_density_limit = 1e-4\n\n# create a map with max ASET as default value\naset_map = np.full_like(slc_data[0], slc.times[-1])\n\n# set walls to nan\naset_map[np.isnan(slc_data[0,:,:])] = np.nan\n\n# 1D loop over all array indices, ix is a two dimensional index\nfor ix in np.ndindex(aset_map.shape):\n    \n    # find spatialy local values which exceed the given limit \n    local_aset = np.where(slc_data[:, ix[0], ix[1]] > soot_density_limit)[0]\n    \n    # if any value exists\n    if len(local_aset) > 0:\n        # use the first, i.e. first in time, as the local ASET value\n        aset_map[ix] = slc.times[local_aset[0]]\n```\n:::\n\n\nWith the computed map, a graphical respresentation of the ASET map is done the \nsame way as with the other quantities. Here, a discrete color map is used.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n# create a discrete (12 values) color map\n# cmap = matplotlib.cm.get_cmap('jet_r', 12)\ncmap = plt.cm.get_cmap('jet_r', 12)\n\n# visualise the data\nplt.imshow(aset_map.T, origin='lower', extent=slc.extent.as_list(), cmap=cmap)\nplt.title(f'ASET Map with Soot Density Limit of {soot_density_limit:.1e}')\nplt.xlabel('x position / m')\nplt.ylabel('y position / m')\nplt.colorbar(orientation='horizontal', label='time / s' );\n\n# save output to file\n#plt.savefig('figs/appartment_aset_map.svg', bbox_inches='tight')\n\n# plt.close()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/p_/ks3trxjx0jd839_g4g0vm4nc0000gn/T/ipykernel_95944/3953631812.py:3: MatplotlibDeprecationWarning: The get_cmap function was deprecated in Matplotlib 3.7 and will be removed in 3.11. Use ``matplotlib.colormaps[name]`` or ``matplotlib.colormaps.get_cmap()`` or ``pyplot.get_cmap()`` instead.\n  cmap = plt.cm.get_cmap('jet_r', 12)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-7-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n## Smoke layer\n\nIn this example, the smoke layer height is analysed. The distinction made here is based on a simple threshold in temperature: The local smoke layer height is given by the lowest point above a given temperature. The evaluation is done based on a slice across the burner and normal to the x-direction.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n# find the slice\nslc = sim.slices.get_by_id('BurnerTempX')\n\n# convert it to a global data structure and get the coordinates\nslc_data, slc_coords = slc.to_global(masked=True, fill=np.nan, return_coordinates=True)\n```\n:::\n\n\nFirst, the data at a arbitrary point in time is visualsied. The white parts represent the obsticles.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n# pick a time index\nit = slc.get_nearest_timestep(150)\n\n# visualise the data\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperature at t={slc.times[it]:.2f}s')\nplt.xlabel('y position / m')\nplt.ylabel('z position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}' )\n\n# save output to file\n#plt.savefig('figs/appartment_temp_slice.svg', bbox_inches='tight')\n\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-9-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nNow, for each y-position the z-indices are found, where the temperature exceedes the limit temperature. The lowest value is the smoke layer height at the y-position.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n# set temperature limit\ntemperature_limit = 75\n\n# create a data array to store the local height values, default \n# is the maximal z-coordinate\nlayer_height = np.full(slc_data.shape[1], slc_coords['z'][-1])\n\n# loop over all indices\nfor ix in range(len(layer_height)):\n    # find indices which exceed the limit\n    lt = np.where(slc_data[it, ix, :] > temperature_limit)[0]\n    # if there are any, pick the lowest one\n    if len(lt) > 0:\n        layer_height[ix] = slc_coords['z'][lt[0]]\n```\n:::\n\n\nThe resulting values can now be plotted over the slice file, to check for plausibility.\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\n# slice data\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperature at t={slc.times[it]:.2f}s')\nplt.xlabel('y position / m')\nplt.ylabel('z position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}' );\n\n# smoke layer height\nplt.plot(slc_coords['y'], layer_height, '.-', color='red')\n\n# save output to file\n#plt.savefig('figs/appartment_temp_slice_height.svg', bbox_inches='tight')\n\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-11-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nUsing the above approach for a single point in time, a loop over all times can \nbe used to compute, e.g., the mean and standard deviation of the smoke layer height.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nlayer_mean = np.zeros_like(slc.times)\nlayer_stddev = np.zeros_like(slc.times)\n\nres = np.zeros(slc_data.shape[1])\n\nfor it in range(len(slc.times)):\n\n    res[:] = slc_coords['z'][-1]\n\n    for ix in range(len(res)):\n        lt = np.where(slc_data[it, ix, :] > temperature_limit)[0]\n        if len(lt) > 0:\n            res[ix] = slc_coords['z'][lt[0]]\n            \n    layer_mean[it] = np.mean(res)\n    layer_stddev[it] = np.std(res)\n```\n:::\n\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\n# plot the mean and stddev values as functions of time\nplt.plot(slc.times, layer_mean, label='Mean Smoke Layer Height')\nplt.plot(slc.times, layer_stddev, label='Stddev of Smoke Layer Height')\nplt.grid()\nplt.legend()\nplt.xlabel('Time / s')\nplt.ylabel('Height / m')\n\n# save output to file\n#plt.savefig('figs/appartment_layer_mean_stddev.svg', bbox_inches='tight')\n\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nText(0, 0.5, 'Height / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-13-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nBoth values can be combined and visualised jointly, where the standard deviation \nis used to indicate a fluctuation band around the mean value.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\n# plot the mean\nplt.plot(slc.times, layer_mean, label='Mean Smoke Layer Height')\n\n# plot a band around the mean, using the stddev as band borders\nplt.fill_between(slc.times, layer_mean-layer_stddev, layer_mean+layer_stddev, color='C0', alpha=0.3)\n\n# show the floor for reference\nplt.ylim(bottom=0)\nplt.grid()\nplt.legend()\nplt.xlabel('Time / s')\nplt.ylabel('Height / m')\n\n# save output to file\n#plt.savefig('figs/appartment_layer_mean_band.svg', bbox_inches='tight')\n\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\nText(0, 0.5, 'Height / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-14-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\nIf parts of the region shall be excluded in the analysis, a coordinate dependent \nmask can be used for this.\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\n# find indices, where the y coordinate is between the given values\nymin = 1\nymax = 4\ncoord_mask = np.where((slc_coords['y'] > ymin) & (slc_coords['y'] < ymax))\n```\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\n# slice data\nplt.imshow(slc_data[it,:,:].T, origin='lower', vmax=200, extent=slc.extent.as_list())\nplt.title(f'Temperature at t={slc.times[it]:.2f}s')\nplt.xlabel('y position / m')\nplt.ylabel('z position / m')\nplt.colorbar(orientation='horizontal', label=f'{slc.quantity.name} / {slc.quantity.unit}' );\n\n# smoke layer height\nplt.plot(slc_coords['y'][coord_mask], layer_height[coord_mask], '.-', color='red')\n\n# save output to file\n#plt.savefig('figs/appartment_temp_slice_height_mask.svg', bbox_inches='tight')\n\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-16-output-1.pdf){fig-pos='H'}\n:::\n:::\n\n\nThe above procedure can be reused, yet the computation of the mean and standard \ndeviation is carried out on the masked values.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfor it in range(len(slc.times)):\n\n    res[:] = slc_coords['z'][-1]\n\n    for ix in np.ndindex(res.shape):\n        lt = np.where(slc_data[it, ix, :] > temperature_limit)[1]\n        if len(lt) > 0:\n            res[ix] = slc_coords['z'][lt[0]]\n    \n    # computation is carried out on the masked values now\n    layer_mean[it] = np.mean(res[coord_mask])\n    layer_stddev[it] = np.std(res[coord_mask])\n```\n:::\n\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n# same plot as above\nplt.plot(slc.times, layer_mean, label='Mean Smoke Layer Height')\nplt.fill_between(slc.times, layer_mean-layer_stddev, layer_mean+layer_stddev, color='C0', alpha=0.3)\nplt.ylim(bottom=0)\nplt.grid()\nplt.legend()\nplt.xlabel('Time / s')\nplt.ylabel('Height / m')\n\n# save output to file\n#plt.savefig('figs/appartment_layer_mean_band_mask.svg', bbox_inches='tight')\n\n# plt.close()\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\nText(0, 0.5, 'Height / m')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](aset_files/figure-pdf/cell-18-output-2.pdf){fig-pos='H'}\n:::\n:::\n\n\n",
    "supporting": [
      "aset_files/figure-pdf"
    ],
    "filters": []
  }
}