# Fdsreader

In order to analyse simulation data computed by FDS with Python, the group of 
Prof. Lukas Arnold has developed the Python module fdsreader. Its aim is to 
read most data output formats generated by FDS and map them to Python data 
structures.

The freely available and open source. The source code is hosted at GitHub: 
[FireDynamics/fdsreader](https://github.com/FireDynamics/fdsreader) and there 
is also an [API documentation](https://firedynamics.github.io/fdsreader/index.html).

## Installing and importing the package

The fdsreader module can be installed via pip (see also the GitHub repository):

```default
pip install fdsreader
```

To learn the basic usage of the fdsreader module we will look at a simple 
FDS scenario. Lets first import the module:

```{python}
import fdsreader
```

Since we will also plot the data we will import `matplotlib`too.
```{python}
import matplotlib.pyplot as plt
```

## Choosing the correct folder

Next, the reader needs to be pointed to the directory, which contains the 
simulation data, especailly the smokeview file.

```{python}
# define the path to the data
path_to_data = '../skript/01-data/first_example'

sim = fdsreader.Simulation(path_to_data)
```

The `Simulation` object `sim` contains now all the information and data about 
the simulaiton output:

```{python}
sim
```

The variable `sim` contains information about the mesh (`MESH`), four slices (`SLCF`) 
and four point measurements (`DEVC`). The additional device – there were just 
three defined in the FDS input file – is the time column.

## Device Data

::: {.callout-tip}
## Devices in FDS
Devices act like virtual sensors, allowing one to record data such as 
temperature, heat flux, gas concentration, velocity, and more, at specific 
locations within the simulation domain. This data can be crucial for 
understanding the behavior of fire and smoke under different conditions.

A device can get a label (`ID`), which makes it much easier to identify in the 
comma separated value (CSV) file created during the simulation. It needs a 
location and a quantity.

Locations can be provided in different ways, we focus her on a single point 
using `XYZ`. However, lines, planes and volumes are possible as well.

The `QUANTITY` parameter expects a string to define what values are to be 
recorded. As an example, let’s take the gas temperature, using `TEMPERATURE`.
:::

The simplest data set is the output of the DEVC directives. The available data 
and meta information can be directly printed:

```{python}
# short reference for convinience, i.e. `devc` contains all devices
devc = sim.devices
print(devc)
```

The Device class contains all relevant information, see 
[device documentation](https://firedynamics.github.io/fdsreader/devc.html).

```{python}
for i in devc:
    print(f"ID: {i.id},\t quantity: {i.quantity_name}, \t position: {i.position}")
```

Individual devices, including the time column, are accessable as dictironary 
entries using their ID as key. The data of each individual device (Device.data) 
is stored as a numpy array:

```{python}
type(devc['Temp_Door_Mid'].data)
```

The length matches the expected value, i.e. 1801, as the simulation time was
and the divices were writen out every second, including the initial time step, 
here at `t = 0s`.

```{python}
len(devc['Time'].data)
```

A raw look at the data (`Device.data`):

```{python}
devc['Temp_Door_Mid'].data
```

The device data can be also visualised with matplotlib:

```{python}
# create the plot
plt.plot(devc['Time'].data, devc['Temp_Door_High'].data)

# label the axes
plt.xlabel("time / s")
devc_id = devc['Temp_Door_High'].id
devc_q = devc['Temp_Door_High'].quantity_name
devc_u = devc['Temp_Door_High'].unit
plt.ylabel(f"{devc_q} ({devc_id}) / {devc_u}")

# add a grid
plt.grid()
```

In the same manner a set of devices can be plotted at once. Like all devices with names starting with Temp_:

```{python}
# loop over all devices
for i in devc:
    
    # consider only devices with an ID that starts with 'Temp_'
    if not i.id.startswith('Temp_'): 
        continue
    
    plt.plot(devc["Time"].data, i.data, label=i.id)
    
plt.legend()
plt.xlabel("time / s")
plt.ylabel('temperature / $^\circ$C')
plt.grid()
```

## HRR Data

::: {.callout-tip}
## Heat Release Rate (HRR)
The crucial parameter in fire modeling, representing the rate at which energy 
is released by a fire, typically measured in kilowatts (kW) or megawatts (MW).
:::

In the same fashion as the `DEVC` data, the data written to the `HRR` file can 
be directly accessed. It is not stored in the `devices` but in the `hrr` element 
of the `Simulation` object.

```{python}
plt.plot(sim.hrr['Time'], sim.hrr['HRR'], label='heat release from fire')

plt.plot(sim.hrr['Time'], sim.hrr['Q_RADI'], label='radiative')
plt.plot(sim.hrr['Time'], sim.hrr['Q_COND'], label='conductive')
plt.plot(sim.hrr['Time'], sim.hrr['Q_CONV'], label='convective')

plt.plot(sim.hrr['Time'], 
         sim.hrr['HRR'] + sim.hrr['Q_RADI'] + sim.hrr['Q_COND'] + sim.hrr['Q_CONV'], 
         color='grey', label='sum', zorder=0)

plt.xlabel('time / s')
plt.ylabel('heat flow rate / kW')
plt.legend()
plt.grid()
```

## Slice Data

::: {.callout-tip}
## Slice data
Sclices are a type of output that allows you to visualize the distribution of 
specific quantities (e.g., temperature, velocity, smoke concentration) within a 
plane of the simulation domain. These slices are essentially cross-sectional 
views of the data, providing insight into how these quantities vary within a 
specific area of the simulated environment.
:::

Data generated by `SLCF` directives span over two or three spatial dimensions 
plus the time dimension. Besides that, they can be distributed across multiple 
meshes.

The data of a slice is stored for each mesh individually. In this simple 
example, there is only a single mesh, yet for formal consistency it still 
needs to be referred.

The data structure is as follows:

```{python}
#| eval: false
#| echo: true
sim.slices[sliceid][meshid].data[timestep, direction1, direction2]
```

where `sliceid` is just the index of the slice, `meshid` is the index of the 
mesh, here in this example 0, and the reference to the data is given by the 
time step id and then the two spatial indices (for two dimensional slices).

In general there are multiple slice objects available:

```{python}
# print available slice data
for slice in sim.slices:
    print(f"Slice Type [2D/3D]: {slice.type}\n  Quantity: {slice.quantity.name}\n", 
          f" Physical Extent: {slice.extent}\n  Orientation [1/2/3]: {slice.orientation}\n")
```

There are multiple ways to find the right slice in the set of all slices. 
One way is to filter for a quantity using the `filter_by_quantity` function or 
choose a slice by its ID.

```{python}
# get the W-VELOCITY slice(s)
w_slice = sim.slices.filter_by_quantity("W-VELOCITY")
print(w_slice)
```

Another way is to select a slice based on its distance to a given point.

```{python}
# select slice, by its distance to a given point
slc = w_slice.get_nearest(x=1, z=2)
print(slc)
```

To access the actual slice data, the actual mesh and a point in time needs to 
be specified. In this example, there is only one mesh, thus the index is 0. The 
function `get_nearest_timestemp` helps to find the right time index.

```{python}
# choose and output the time step, next to t=75 s
it = slc.get_nearest_timestep(25)
print(f"Time step: {it}")
print(f"Simulation time: {slc.times[it]}")
```

The following example illustrates the visualisation of the data and steps needed 
to adjust the representation. The needed adjustments are due to the data 
orientation expected by the `imshow` function.

```{python}
# choose the temperature slice in y-direction
slc = sim.slices.filter_by_quantity('TEMPERATURE').get_nearest(x=3, y=0)
print(slc)
# only one mesh
slc_data = slc[0].data
print(slc_data)
```

```{python}
# Initial visualasation of the data at time t=50 s
it = slc.get_nearest_timestep(50)
plt.imshow(slc_data[it])
```

```{python}
# Access the transpose data using ndarray.T and set the origin of the output
plt.imshow(slc_data[it].T, origin='lower')
```

```{python}
# Initial visualasation of the data at time t=50 s
# Finally, also the extend is specified to move from index to physical space
# Additionally, the maximal value is set using the vmax argument
plt.imshow(slc_data[it].T, 
           origin='lower',
           vmax=200,
           extent=slc.extent.as_list())
plt.colorbar(label='temperature / C', orientation='horizontal')
plt.xlabel('x coordinate / m')
plt.ylabel('z coordinate / m')
```

```{python}
# Example for a multi plot
list_t = [0, 50, 100, 200, 300, 400]
fig, axs = plt.subplots(2,3, sharex=True, sharey=True)
for i in range(len(list_t)):
    it = slc.get_nearest_timestep(list_t[i])
    axs.flat[i].imshow(slc_data[it].T,
                       vmin=20,
                       vmax=400,
                       origin='lower', 
                       extent=slc.extent.as_list())
    axs.flat[i].set_title(f"t={slc.times[it]:.1f}")
```